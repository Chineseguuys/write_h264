# 指数哥伦布编码

## 一. 熵编码

熵编码是无损编码 。

指数哥伦布编码是熵编码的一种。

SPS 和 PPS 存放了解码 h.264 码流解码时必要的信息。而 SPS 和 PPS 中存放数据的编码就是指数哥伦布编码。

* h.264 码流中的操作单位是 bit, 而不是 bytes。
* 指数哥伦布编码是一种变长编码，这也是熵编码的主要特性之一。

## 二. 指数哥伦布编码的种类

* 无符号指数哥伦布熵编码 ue(v)
* 有符号指数哥伦布熵编码 se(v)
* 映射指数哥伦布熵编码 me(v)
* 截断指数哥伦布熵编码 te(v)

## 三. 无符号指数哥伦布熵编码 ue(v)[^1]

1. 先把要编码的数字 + 1， 假设我们要编码的数据是4，那么先对4加一，变成了5
2. 将加1之后的数字 5先转化为二进制， 就是 101
3. 转化为二进制之后，我们看转化成的二进制有多少位，然后在前面补位数 - 1 个 0。比方说，101 有3位，那么我们需要在前面补充 2 个 0
4. 进行无符号指数哥伦布编码之后得到的二进制的码流就是 00101

### 3.1 为什么需要补0

假设我们有两个数字，4 和 5，我们想要把这两个数字编码为一路二进制的流。我们利用上面提到的步骤来进行编码

* 4， 编码后的码流是 101 （没有经过补充  0）
* 5，编码后的码流是 110 （没有经过补充 0）

把这两个二进制数字相连，得到了下面的码流 101110。 如果在解码端我们只拿到了这样一个码流，我们无法判断这个码流究竟代表了几个数字，一个这个码流的每一个数字的长度是多少。

 ## 四. 有符号的指数哥伦布熵编码 se(v)

1. 先把要编码的数字取绝对值后转化为二进制，例如我们要编码的数字是 -5, 取绝对值之后是 +5， 转化为二进制就是 101
2. 在二进制序列的后面增加一位符号：0表示为正数，1表示为负数。二进制序列就是 1011
3. 查看现在的二进制的序列的长度，在前面补充上长度 -1 个 0， 二进制的序列就是 0001011

## 五. 映射指数哥伦布熵编码 me(v)

我们先来编码数字 5, 得到的码流是 00110， 占用了 5个 bit的空间

我们再来编码 47 这个数字，得到的码流就是 00000110000， 占用了 11个 bit 的空间

* 我们发现，指数哥伦布熵编码有一个特性，那就是数字特别大的时候，占用的空间就会非常的大。那么如果我们编码的数字在某一个区间比较小的范围内，而这个范围内的数字都非常的大，有没有什么方法可以节省编码的空间？

为了解决这个问题，就出现了映射指数哥伦布编码

映射指数哥伦布熵编码提供了一个码表，当你遇到了一段码流的时候，你要先根据无符号指数哥伦布熵编码进行解码，然后得到的结果其实是一个码表的索引。例如，你解码出来的数据是 2，那么你到码表当中，找到角标是 2 的元素出来就是最终的结果

## 六. 截断指数哥伦布熵编码 te(v)

截断指数哥伦布熵编码要解决的问题其实和映射指数哥伦布熵编码要解决的问题是差不多的。

当语法元素以截断指数哥伦布解码时，首先需要判断的是语法元素的取值 范围，假定是 [0, x], x >=1。 根据 x 的取值情况，语法元素根据不同的情况进行解析。若 x > 1, 解析方法同无符号指数哥伦布熵编码相同，如果 x=1, 语法元素值等同于下一位 bit 值的取反。



## Notes:  指数值 k 的无符号指数哥伦布熵编码[^2]

用来表示非负整数的k 阶指数哥伦布熵编码可用下面的步骤进行生成：

1. 将数字以二进制形式写出(B)， 去掉最低的 k 个 bit 位 (D)， 之后对去除了最低的 k 个 bit 位后的数字 + 1 ($A = B + 1$)
2. 计算 A 的比特个数 C， 将这个数字 -1， 即是需要增加的前导0的个数($Z = C - 1$)
3. 将第一步中去掉的最低 k 个比特位补回比特串的尾部（Z个0 + A + D）

 ```
       Step 1                         Step 2           Step 3 
  0 => B = 0   ,D = None, A = 1    => C = 1 , Z = 0 => 1
  1 => B = 1   ,D = None, A = 10   => C = 2 , Z = 1 => 010
  2 => B = 10  ,D = None ,A = 11   => C = 2 , Z = 1 => 011
  3 => B = 11  ,D = None ,A = 100  => C = 3 , Z = 2 => 00100
  4 => B = 100 ,D = None ,A = 101  => C = 3 , Z = 2 => 00101
  5 => B = 101 ,D = None ,A = 110  => C = 3 , Z = 2 => 00110
  6 => B = 110 ,D = None ,A = 111  => C = 3 , Z = 2 => 00111
  7 => B = 111 ,D = None ,A = 1000 => C = 4 , Z = 3 => 0001000
  8 => B = 1000,D = None ,A = 1001 => C = 4 , Z = 3 => 0001001
 ```

k = 1 的指数哥伦布熵编码情况如下所示

```
      Step 1                      Step 2           Step 3
 0 => B = 0   ,D = 0 , A = 1   => C = 1 , Z = 0 => 10
 1 => B = 1   ,D = 1 , A = 1   => C = 1 , Z = 0 => 11
 2 => B = 10  ,D = 0 , A = 10  => C = 2 , Z = 1 => 0100
 3 => B = 11  ,D = 1 , A = 10  => C = 2 , Z = 1 => 0101
 4 => B = 100 ,D = 0 , A = 11  => C = 2 , Z = 1 => 0110
 5 => B = 101 ,D = 1 , A = 11  => C = 2 , Z = 1 => 0111
 6 => B = 110 ,D = 0 , A = 100 => C = 3 , Z = 2 => 001000
 7 => B = 111 ,D = 1 , A = 100 => C = 3 , Z = 2 => 001001
 8 => B = 1000,D = 0 , A = 101 => C = 3 , Z = 2 => 001010
```





[^1]: 这里的指数哥伦布熵编码的指数 $k = 0$ 
[^2]: https://zh.m.wikipedia.org/zh-hans/%E6%8C%87%E6%95%B0%E5%93%A5%E4%BC%A6%E5%B8%83%E7%A0%81



